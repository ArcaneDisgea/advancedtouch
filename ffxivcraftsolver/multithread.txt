enum for phase (simulate, mutate, terminate)	// not atomic
main switches phase for go signal



int i = atomic_fetch_add(counter, memory_order_relaxed);
if (i > 100) return;
else { dothething(); }

each thread stores its own sums, only emit after all are complete


threads:
	wait for gosignal cv
	process until no work left
	lock outputmutex
		add sums
		increment donecounter
		unlock
	signal donecv
	wait

main:
	send gosignal cv
	wait for donecv (donecounter == threads, outputmutex)
	output gen count if time
	setup
	donecounter = 0
	signal go


sender:
	take lock
	set variable
	unlock
	notify

reciever:
	take lock
	wait on variable
	unlock

Do not heuristic?
	"we must not point the population towards a solution that seems good"

solving-main:
	mutated.clear(); mutated.reserve();
	threadgo
	wait for threaddone
	now 'mutated' contains all trials
	sequences = move(mutated);
	do simulations
	reset trialresults
	reset counters = 0;		(done by setOrder)
	reset threaddone = 0;	(done by setOrder)
	sort sequences by fitness;
		preserve best outcome for display stats, or for final result


solving-threads:
	(normal sim functions)
	wait for gosolve
	each have own unordered_map<int, sequence> for output
	each take 1 trial from 0 to count/2 (use counters to take dibs)
	mutate per trial policy, add output to localtrials
	when all trials accounted for, report in: append localtrials to mutated
	wait for gosim

trial policy:
	all sequences produce 2 children
	top 5%:
		1 child no mutations, 1 child 1 mutation
	next 20%:
		both children 1 mutation
	next 20%:
		both children 2 mutations
	next 5%:
		both children 3 mutations
	last 50%:
		eliminated


Ranking:
	first by too many cross-class
	normal:
		success amount (if both 0, progress)
		hq percent
	hqorbust:
		hq percent (if both 0, progress)
	nqonly:
		success amount (if both 0, progress)
	common:
		invalid actions
		steps